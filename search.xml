<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法</title>
    <url>/2023/11/04/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<center><h2>加训，狠狠的加训</h2></center>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157 (Rated for Div. 2)</title>
    <url>/2023/11/07/edu157(d2)/</url>
    <content><![CDATA[<h1 id="Educational-Codeforces-Round-157-Rated-for-Div-2"><a href="#Educational-Codeforces-Round-157-Rated-for-Div-2" class="headerlink" title="Educational Codeforces Round 157 (Rated for Div. 2)"></a>Educational Codeforces Round 157 (Rated for Div. 2)</h1><h3 id="A-Treasure-Chest"><a href="#A-Treasure-Chest" class="headerlink" title="A - Treasure Chest"></a>A - Treasure Chest</h3><p>一般规律</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int x,y,k;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">    cout &lt;&lt; ((x &gt; y) ? x :(((y - x) &lt;= k) ? y : (y-x+y-k)));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Points-and-Minimum-Distance"><a href="#B-Points-and-Minimum-Distance" class="headerlink" title="B - Points and Minimum Distance"></a>B - Points and Minimum Distance</h3><p>其实就是分成三个+和三个-的，排序后后一项减前一项，前n项当x后n项当y，注意不要y-x即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">const int NN=1010;</span><br><span class="line">int a[N];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;2*n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+2*n);</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=1;i&lt;n;i++)ans+=a[i]-a[i-1];</span><br><span class="line">    for(int i=n+1;i&lt;2*n;i++)ans+=a[i]-a[i-1];</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;&lt;&lt;a[n+i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Torn-Lucky-Ticket"><a href="#C-Torn-Lucky-Ticket" class="headerlink" title="C - Torn Lucky Ticket"></a>C - Torn Lucky Ticket</h3><p>如果使用暴力，那么复杂度10<em>n</em>n<br>解决这种求多少对的问题，一般是寻找字符串的共同点然后把他用共同点代替<br>我们只保存一个字符串的长度和和即可，和即为他的贡献度<br>i，j和j，i会作为两种不同的对被计算，去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">const int NN=1010;</span><br><span class="line">int a[NN][NN];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;string&gt;s(n);</span><br><span class="line">    map&lt;pair&lt;int,int&gt;,int&gt; m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        int all=0;</span><br><span class="line">        for(int j=0;j&lt;s[i].size();j++)all+=s[i][j]-&#x27;0&#x27;;</span><br><span class="line">        m[&#123;s[i].size(),all&#125;]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        int len=s[i].size();</span><br><span class="line">        int all=0;</span><br><span class="line">        for(int j=0;j&lt;len;j++)all += s[i][j]-&#x27;0&#x27;;</span><br><span class="line">        int f = 0;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        int cntt = 0;</span><br><span class="line">        for(int j=0;j&lt;len;j++)&#123;</span><br><span class="line">            f++;</span><br><span class="line">            cnt += s[i][j]-&#x27;0&#x27;;//正着来</span><br><span class="line">            cntt += s[i][len-j-1]-&#x27;0&#x27;;//反着来</span><br><span class="line">            int ff=len-f;</span><br><span class="line">            //cout&lt;&lt;-all+2*cnt&lt;&lt;&#x27; &#x27;;</span><br><span class="line">            int x=cnt-all+cnt;</span><br><span class="line">            int y=cntt-all+cntt;</span><br><span class="line">            ans+=m[&#123;f-ff,cnt-all+cnt&#125;];</span><br><span class="line">            //cout&lt;&lt;&#x27;-&#x27;&lt;&lt;m[&#123;f-ff,x&#125;]&lt;&lt;&#x27; &#x27;&lt;&lt;ans;</span><br><span class="line">            if(!(j==len-1))//为了避免出现把（1，2）（2，1）重复计数的情况，当长度等于len时，反着来的部分就不要了</span><br><span class="line">                ans+=m[&#123;f-ff,y&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    //cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="D-XOR-Construction"><a href="#D-XOR-Construction" class="headerlink" title="D - XOR Construction"></a>D - XOR Construction</h3><p>异或，从二进制入手，寻找性质<br>发现只要确定b1，那么b就能全部确定<br>b1 ^ b2&#x3D;a1，b2 ^ a2&#x3D;b3，b1 ^ b3&#x3D;a1 ^ a2<br>在0-n-1的情况下，我们可以计算出每个位置的1的出现的次数<br>假如在i位置1出现x次，那么异或后1就会出现n-x次，答案只有两种情况，其中一种一定是正确的<br>枚举我们想要的x的每一位就好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt;v(n-1);</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)cin &gt;&gt; v[i];</span><br><span class="line">    for(int i=1;i&lt;n-1;i++)v[i] ^= v[i-1];//预处理</span><br><span class="line">    int x=0;</span><br><span class="line">    for(int i=0;i&lt;20;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int a[2]&#123;&#125;,b[2]&#123;&#125;;//初始化都为0</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j &gt;&gt; i &amp; 1] +=1;//取j的第i位</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;n-1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[v[j] &gt;&gt; i &amp; 1] +=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(a[1]!=b[1]) x |= 1 &lt;&lt; i;异或x的第i位</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    for(int i=0;i&lt;n-1;i++)cout &lt;&lt; (v[i]^x) &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    //cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 157 (Rated for Div. 2)</title>
    <url>/2023/11/08/cf%20908(d2)/</url>
    <content><![CDATA[<h1 id="Codeforces-Round-908-Div-2"><a href="#Codeforces-Round-908-Div-2" class="headerlink" title="Codeforces Round 908 (Div. 2)"></a>Codeforces Round 908 (Div. 2)</h1><h3 id="A-Secret-Sport"><a href="#A-Secret-Sport" class="headerlink" title="A - Secret Sport"></a>A - Secret Sport</h3><p>赢下最后一局才会胜利结束游戏，最后一局的胜者是赢家</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    cout&lt;&lt;s[n-1]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="B-Two-Out-of-Three"><a href="#B-Two-Out-of-Three" class="headerlink" title="B - Two Out of Three"></a>B - Two Out of Three</h3><p>我们只关心出现次数大于等于2的种类<br>当种类小于2时必定没有解<br>超过2时一个种类赋予1，2类型，一个种类赋予1，3类型，其他值随便赋1，2，3即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;cin&gt;&gt;n;</span><br><span class="line">    map&lt;int,int&gt;m;</span><br><span class="line">    vector&lt;int&gt;v(n);</span><br><span class="line">    set&lt;int&gt;s;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">        m[v[i]]++;</span><br><span class="line">        if(m[v[i]]&gt;=2)s.insert(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(s.size()&lt;2)cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int x=0,y=0;</span><br><span class="line">        for(auto k : s)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!x)x=k;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                y=k;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int f=0;</span><br><span class="line">        int ff=0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(x==v[i]) &#123; if(!f)cout &lt;&lt; 1 &lt;&lt; &#x27; &#x27;;else cout&lt;&lt;2&lt;&lt;&#x27; &#x27;; f++; &#125;</span><br><span class="line">            else if(y==v[i]) &#123; if(!ff)cout &lt;&lt; 1 &lt;&lt; &#x27; &#x27;;else cout&lt;&lt;3&lt;&lt;&#x27; &#x27;; ff++; &#125;</span><br><span class="line">            else cout&lt;&lt;1&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="C-Anonymous-Informant"><a href="#C-Anonymous-Informant" class="headerlink" title="C - Anonymous Informant"></a>C - Anonymous Informant</h3><p>找规律。 固定点ax&#x3D;x左移x位后一定在第ax位， 那么我们可以猜测论只有第n位才能反向操作<br>ai要回到第个位置，必须满足(ai+i)%n&#x3D;ai，那么只有当i&#x3D;&#x3D;n时满足。<br>我们对最后一位进行操作，要回到原来的位置，那么对数组的影响是，数组会变成[a-an+1]+[1+n-an]<br>但是，当遇到最后一位an＞n时，一定不合法，因为，不满足ax&#x3D;x固定点。<br>所以我们一直操作最后一位，持续至多次，直到碰到循环或者an＞n停止。我们设cnt为我们现在反向操作的最后一个位置，我们可以一直处理cnt&#x3D;(cnt-a[cnt]+n)%n就能做到最后一位的转移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int N=2e6+5;</span><br><span class="line">int a[N],b[N];</span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i], b[i]=0;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    while(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[cnt]&gt;n)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;return ; &#125;</span><br><span class="line">        cnt=(cnt-a[cnt]+n)%n;</span><br><span class="line">        if(!cnt)cnt = n;</span><br><span class="line">        if(b[cnt])&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;return ; &#125;</span><br><span class="line">        b[cnt]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL);</span><br><span class="line">    cout.tie(NULL);</span><br><span class="line">    int t=1;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)solve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
